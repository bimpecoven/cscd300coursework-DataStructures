In my implementation of the BST data structure i used a simple constructer that only assigns the 
root to null. the Node class i used for this has 3 node fields within it, Parent, left, and right. these will act as the linkages between the nodes and form the tree. the min and max methods are very simple, they check the left or right (depending on min or max) if it is null and if its not they advance in the direction. this will ultimately get us to the min or max. our search method uses a less than comparator to decide weather or not we should continue the search left of right of the node were checking. it goes until weâ€™ve found the node or until it hits null, then returns. Insert uses two nodes to keep track of link changes that will be made. it uses similar logic to the search method with comparators to decide whether or not we need to continue left or right. after it will assign the left or right depending on where the node was inserted. delete calls the search method , if it is not null will delete the node with the key that was passed in, then returning the deleted node. we use the transplant helper method to make the code cleaner and avoid confusing ourself with reassigning the node linkages within the delete method and the helper delete method will use similar logic we have explained before to decide where to relink nodes and remove the one that matches the given key. successor and predecessor if the right node of the given node is null we return max or min depending on successor or predecessor. otherwise were simply trying to get the higher or lower node of the given node. the traversals are all recursive, calling some sort of link node(right, left, parent) until we hit a stopping casino print. we simply pass in different parameters depending on what move we need to do.